<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Map Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            overflow: hidden;
            height: 100vh;
        }

        .game-container {
            display: flex;
            height: 100vh;
        }

        .map-container {
            flex: 1;
            position: relative;
            background: linear-gradient(45deg, #0f1419 0%, #1a2332 50%, #0f1419 100%);
            overflow: hidden;
        }

        .map-canvas {
            width: 100%;
            height: 100%;
            position: relative;
            cursor: grab;
            z-index: 1; /* above webgl */
        }

        .map-canvas:active {
            cursor: grabbing;
        }

        .map-object {
            position: absolute;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 3px solid #00ff88;
            background: radial-gradient(circle, rgba(0,255,136,0.3) 0%, rgba(0,255,136,0.1) 70%, transparent 100%);
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            box-shadow: 0 0 20px rgba(0,255,136,0.5);
            z-index: 2; /* above map canvas */
        }

        .map-object:hover {
            transform: scale(1.2);
            box-shadow: 0 0 30px rgba(0,255,136,0.8);
        }

        .map-object.discovered {
            border-color: #ff6b35;
            background: radial-gradient(circle, rgba(255,107,53,0.3) 0%, rgba(255,107,53,0.1) 70%, transparent 100%);
            box-shadow: 0 0 20px rgba(255,107,53,0.5);
        }

        .map-object.unlocked {
            border-color: #ffd700;
            background: radial-gradient(circle, rgba(255,215,0,0.3) 0%, rgba(255,215,0,0.1) 70%, transparent 100%);
            box-shadow: 0 0 20px rgba(255,215,0,0.5);
        }

        .sidebar {
            width: 350px;
            background: rgba(0,0,0,0.8);
            backdrop-filter: blur(10px);
            border-left: 1px solid rgba(255,255,255,0.1);
            padding: 20px;
            overflow-y: auto;
        }


        .toolbar {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }


        .object-details {
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            display: none;
        }

        .object-details.active {
            display: block;
        }

        .object-name {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 10px;
            color: #00ff88;
        }

        .object-description {
            margin-bottom: 15px;
            line-height: 1.5;
        }


        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: #00ff88;
            color: #000;
        }

        .btn-secondary {
            background: #ff6b35;
            color: white;
        }

        .btn-info {
            background: #4fc3f7;
            color: white;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        .llm-content {
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            display: none;
        }

        .llm-content.active {
            display: block;
        }

        .content-type-tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
        }

        .tab {
            padding: 5px 10px;
            background: rgba(255,255,255,0.1);
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
        }

        .tab.active {
            background: #00ff88;
            color: #000;
        }

        .video-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .video-container.active {
            display: flex;
        }

        .video-player {
            width: 80%;
            height: 80%;
            border-radius: 10px;
        }

        .close-video {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            font-size: 24px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }

        .loading.active {
            display: block;
        }

        .spinner {
            border: 3px solid rgba(255,255,255,0.3);
            border-top: 3px solid #00ff88;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0,255,136,0.9);
            color: #000;
            padding: 15px 20px;
            border-radius: 10px;
            transform: translateX(400px);
            transition: transform 0.3s ease;
            z-index: 1001;
        }

        .notification.show {
            transform: translateX(0);
        }

        .chatbot-section {
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .chatbot-section h3 {
            margin-bottom: 15px;
            color: #00ff88;
            font-size: 1.1em;
        }

        .chatbot-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .chatbot-container label {
            font-size: 14px;
            color: rgba(255,255,255,0.8);
            margin-bottom: 5px;
        }

        .chatbot-container textarea {
            background: rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 5px;
            padding: 10px;
            color: white;
            font-family: inherit;
            font-size: 14px;
            resize: vertical;
            min-height: 80px;
            transition: border-color 0.3s ease;
        }

        .chatbot-container textarea:focus {
            outline: none;
            border-color: #00ff88;
            box-shadow: 0 0 5px rgba(0,255,136,0.3);
        }

        .chatbot-container textarea::placeholder {
            color: rgba(255,255,255,0.5);
        }

        .chat-response {
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 15px;
            margin-top: 10px;
            min-height: 60px;
            display: none;
            border-left: 3px solid #00ff88;
        }

        .chat-response.active {
            display: block;
        }

        .chat-response.loading {
            display: flex;
            align-items: center;
            justify-content: center;
            color: rgba(255,255,255,0.7);
        }

        .chat-response.loading::before {
            content: '';
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255,255,255,0.3);
            border-top: 2px solid #00ff88;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 10px;
        }

        /* WebGL canvas behind UI */
        .webgl-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }
    </style>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.159.0/build/three.module.js",
            "three/examples/jsm/": "https://unpkg.com/three@0.159.0/examples/jsm/"
        }
    }
    </script>
</head>
<body>
    <div class="game-container">
        <div class="map-container">
            <div class="map-canvas" id="mapCanvas">
                <!-- Map objects will be dynamically added here -->
            </div>
        </div>

        <div class="sidebar">
            <div class="toolbar">
                <button class="btn btn-primary" id="toggleMarkersBtn" onclick="toggleMarkers()">Hide Markers</button>
            </div>
            <div class="object-details" id="objectDetails">
                <div class="object-name" id="objectName"></div>
                <div class="object-description" id="objectDescription"></div>

                <div class="llm-content" id="llmContent">
                    <div class="content-type-tabs">
                        <div class="tab active" onclick="showContentType('description')">Description</div>
                    </div>
                    <div id="contentDisplay"></div>
                </div>
            </div>

            <div class="loading" id="loading">
                <div class="spinner"></div>
                <div>Generating content...</div>
            </div>

            <div class="chatbot-section">
                <h3>Conversational Chatbot</h3>
                <div class="chatbot-container">
                    <label for="chatInput">Ask your map guide anything:</label>
                    <textarea id="chatInput" placeholder="Type your question here..."></textarea>
                    <button class="btn btn-primary" onclick="sendChatMessage()">Ask Map Guide</button>
                    <div class="chat-response" id="chatResponse"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="video-container" id="videoContainer">
        <button class="close-video" onclick="closeVideo()">&times;</button>
        <video class="video-player" id="videoPlayer" controls>
            Your browser does not support the video tag.
        </video>
    </div>

    <div class="notification" id="notification"></div>

    <script>
        let mapObjects = [];
        let selectedObject = null;
        let playerId = generatePlayerId();

        // Initialize the game
        async function initGame() {
            await loadMapObjects();
            renderMap();
        }

        // Generate unique player ID
        function generatePlayerId() {
            return 'player_' + Math.random().toString(36).substr(2, 9) + '_' + Date.now();
        }

        // Load map objects from API
        async function loadMapObjects() {
            try {
                const response = await fetch('/api/Map/objects');
                mapObjects = await response.json();
            } catch (error) {
                console.error('Error loading map objects:', error);
                showNotification('Error loading map objects', 'error');
            }
        }


        // Render the map
        function renderMap() {
            const canvas = document.getElementById('mapCanvas');
            canvas.innerHTML = '';

            mapObjects.forEach(obj => {
                const element = document.createElement('div');
                element.className = 'map-object';
                element.style.left = obj.x + 'px';
                element.style.top = obj.y + 'px';
                element.innerHTML = getObjectIcon(obj.type);
                element.title = obj.name;
                
                if (obj.isUnlocked) {
                    element.classList.add('unlocked');
                } else if (obj.isDiscoverable) {
                    element.classList.add('discovered');
                }

                element.onclick = () => selectObject(obj);
                canvas.appendChild(element);
            });
        }

        // Toggle 2D markers visibility and allow interacting with 3D map
        function toggleMarkers() {
            const canvas = document.getElementById('mapCanvas');
            const btn = document.getElementById('toggleMarkersBtn');
            const hidden = canvas.style.display === 'none';
            if (hidden) {
                canvas.style.display = '';
                btn.textContent = 'Hide Markers';
                // restore pointer events to markers layer
                canvas.style.pointerEvents = '';
            } else {
                canvas.style.display = 'none';
                btn.textContent = 'Show Markers';
            }
        }

        // Get icon for object type
        function getObjectIcon(type) {
            const icons = {
                'Aircraft': 'âœˆï¸',
                'Spacecraft': 'ðŸš€',
                'Satellite': 'ðŸ›°ï¸',
                'Helicopter': 'ðŸš',
                'Rocket': 'ðŸš€',
                'Museum': 'ðŸ›ï¸',
                'default': 'â­'
            };
            return icons[type] || icons.default;
        }

        // Select an object
        function selectObject(obj) {
            // Clear previous description content when selecting new object
            const llmContent = document.getElementById('llmContent');
            llmContent.classList.remove('active');
            const contentDisplay = document.getElementById('contentDisplay');
            contentDisplay.textContent = '';
            
            selectedObject = obj;
            showObjectDetails(obj);
            logInteraction(obj.id, 'click');
            
            // Automatically generate description when object is selected
            generateContent('description');
        }

        // Expose data/functions for module script (3D placement)
        window.getMapObjects = () => mapObjects;
        window.selectObject = selectObject;

        // Show object details
        function showObjectDetails(obj) {
            const details = document.getElementById('objectDetails');
            const name = document.getElementById('objectName');
            const description = document.getElementById('objectDescription');

            name.textContent = obj.name;
            description.textContent = obj.description || 'No description available.';
            
            // Clear the LLM content display when showing new object details
            const llmContent = document.getElementById('llmContent');
            llmContent.classList.remove('active');
            const contentDisplay = document.getElementById('contentDisplay');
            contentDisplay.textContent = '';
            
            details.classList.add('active');
        }

        // Generate content using LLM
        async function generateContent(contentType) {
            if (!selectedObject) return;

            showLoading(true);
            
            try {
                const response = await fetch('/api/LLM/generate-content', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        playerId: playerId,
                        mapObjectId: selectedObject.id,
                        contentType: contentType
                    })
                });

                if (!response.ok) {
                    // Try to extract error message from response
                    let errorMessage = 'Failed to generate content';
                    try {
                        // Clone the response so we can read it multiple times if needed
                        const responseText = await response.text();
                        if (responseText) {
                            try {
                                const errorData = JSON.parse(responseText);
                                if (errorData && typeof errorData === 'object') {
                                    // Handle different error response formats
                                    if (errorData.error) {
                                        // errorData.error can be a string or an object with a message property
                                        if (typeof errorData.error === 'string') {
                                            errorMessage = errorData.error;
                                        } else if (errorData.error.message) {
                                            errorMessage = errorData.error.message;
                                        } else {
                                            errorMessage = String(errorData.error);
                                        }
                                    } else if (errorData.message) {
                                        errorMessage = errorData.message;
                                    }
                                } else if (typeof errorData === 'string') {
                                    errorMessage = errorData;
                                }
                            } catch (jsonError) {
                                // If JSON parsing fails, use the raw text
                                errorMessage = responseText || errorMessage;
                            }
                        }
                    } catch (readError) {
                        console.error('Error reading error response:', readError);
                        errorMessage = `HTTP ${response.status}: ${response.statusText}`;
                    }
                    console.error('API Error:', {
                        status: response.status,
                        statusText: response.statusText,
                        message: errorMessage
                    });
                    throw new Error(errorMessage);
                }

                const data = await response.json();
                displayGeneratedContent(data.content, contentType);
                
                showNotification('Content generated successfully!', 'success');
            } catch (error) {
                console.error('Error generating content:', error);
                const errorMsg = error.message || 'Error generating content';
                showNotification(errorMsg, 'error');
            } finally {
                showLoading(false);
            }
        }

        // Display generated content
        function displayGeneratedContent(content, contentType) {
            const contentDisplay = document.getElementById('contentDisplay');
            contentDisplay.textContent = content;
            
            const llmContent = document.getElementById('llmContent');
            llmContent.classList.add('active');
            
            // Since there's only one tab now, just ensure it's active
            showContentType('description');
        }

        // Show content type tab
        function showContentType(type) {
            const tabs = document.querySelectorAll('.tab');
            tabs.forEach(tab => tab.classList.remove('active'));
            
            // Find the tab that matches the content type
            const targetTab = Array.from(tabs).find(tab => 
                tab.textContent.toLowerCase() === type.toLowerCase()
            );
            
            if (targetTab) {
                targetTab.classList.add('active');
            }
        }

        // Show/hide loading
        function showLoading(show) {
            const loading = document.getElementById('loading');
            if (show) {
                loading.classList.add('active');
            } else {
                loading.classList.remove('active');
            }
        }

        // Show notification
        function showNotification(message, type = 'info') {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.className = `notification show ${type}`;
            
            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000);
        }

        // Log interaction
        async function logInteraction(objectId, interactionType, data = null) {
            try {
                await fetch(`/api/Map/objects/${objectId}/interact`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        playerId: playerId,
                        interactionType: interactionType,
                        interactionData: data
                    })
                });
            } catch (error) {
                console.error('Error logging interaction:', error);
            }
        }


        // Close video
        function closeVideo() {
            const videoContainer = document.getElementById('videoContainer');
            const videoPlayer = document.getElementById('videoPlayer');
            
            videoContainer.classList.remove('active');
            videoPlayer.pause();
            videoPlayer.currentTime = 0;
        }

        // Send chat message to the map guide
        async function sendChatMessage() {
            const chatInput = document.getElementById('chatInput');
            const chatResponse = document.getElementById('chatResponse');
            const message = chatInput.value.trim();

            if (!message) {
                showNotification('Please enter a message', 'error');
                return;
            }

            if (!selectedObject) {
                showNotification('Please select a map object first', 'error');
                return;
            }

            // Show loading state
            chatResponse.className = 'chat-response loading';
            chatResponse.textContent = 'Map guide is thinking...';

            try {
                const response = await fetch('/api/LLM/generate-content', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        playerId: playerId,
                        mapObjectId: selectedObject.id,
                        contentType: 'conversation',
                        specificRequest: message
                    })
                });

                if (!response.ok) {
                    throw new Error('Failed to get response from map guide');
                }

                const data = await response.json();
                
                // Display the response
                chatResponse.className = 'chat-response active';
                chatResponse.textContent = data.content;
                
                // Clear the input
                chatInput.value = '';
                
                showNotification('Map guide responded!', 'success');
            } catch (error) {
                console.error('Error sending chat message:', error);
                chatResponse.className = 'chat-response active';
                chatResponse.textContent = 'Sorry, I encountered an error. Please try again.';
                showNotification('Error communicating with map guide', 'error');
            }
        }

        // Initialize the game when page loads
        document.addEventListener('DOMContentLoaded', initGame);
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader.js';
        import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
        import { OutlinePass } from 'three/examples/jsm/postprocessing/OutlinePass.js';
        import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';

        const container = document.querySelector('.map-container');
        if (!container) {
            console.warn('Three.js init skipped: .map-container not found');
        } else {
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.75));
            renderer.setSize(container.clientWidth, container.clientHeight);
        container.prepend(renderer.domElement);
        renderer.domElement.classList.add('webgl-canvas');

            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 10000);
            const controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 5;
            controls.maxDistance = 5000;

            scene.add(new THREE.HemisphereLight(0xffffff, 0x202020, 0.8));
            const dir = new THREE.DirectionalLight(0xffffff, 0.6);
            dir.position.set(100, 200, 100);
            scene.add(dir);

            // Postprocessing composer: render -> hoverOutline -> mild bloom (hover only)
            const composer = new EffectComposer(renderer);
            const renderPass = new RenderPass(scene, camera);
            composer.addPass(renderPass);
            // Stronger outline for hovered exhibit
            const hoverOutlinePass = new OutlinePass(new THREE.Vector2(container.clientWidth, container.clientHeight), scene, camera);
            hoverOutlinePass.edgeStrength = 3.0;
            hoverOutlinePass.edgeGlow = 0.0;
            hoverOutlinePass.edgeThickness = 1.6;
            hoverOutlinePass.visibleEdgeColor.set(0x00ff88);
            hoverOutlinePass.hiddenEdgeColor.set(0x004422);
            composer.addPass(hoverOutlinePass);
            const BASE_BLOOM_STRENGTH = 0.0;
            const HOVER_BLOOM_STRENGTH = 0.45;
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(container.clientWidth, container.clientHeight), BASE_BLOOM_STRENGTH, 0.6, 0.85);
            composer.addPass(bloomPass);

            const gltfLoader = new GLTFLoader();
            const dracoLoader = new DRACOLoader();
            dracoLoader.setDecoderPath('https://unpkg.com/three@0.159.0/examples/jsm/libs/draco/');
            gltfLoader.setDRACOLoader(dracoLoader);

            let terrain = null;
            let planeTemplate = null;
            const exhibitGroups = [];
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            let hoveredGroup = null;

            // Load terrain first
            gltfLoader.load('/assets/mansion_map.glb', (gltf) => {
                terrain = gltf.scene;
                scene.add(terrain);

                const box = new THREE.Box3().setFromObject(terrain);
                const size = box.getSize(new THREE.Vector3());
                const center = box.getCenter(new THREE.Vector3());

                controls.target.copy(center);
                const maxDim = Math.max(size.x, size.y, size.z);
                const fitDist = maxDim * 1.2;
                camera.position.set(center.x - fitDist * 0.7, center.y + fitDist * 0.5, center.z + fitDist * 0.7);
                controls.update();

                // After terrain, load plane template
                loadPlaneTemplate();
            }, (evt) => {
                if (evt.lengthComputable) {
                    const pct = (evt.loaded / evt.total * 100).toFixed(1);
                    console.log(`Loading model: ${pct}%`);
                } else {
                    console.log(`Loading model: ${evt.loaded} bytes`);
                }
            }, (err) => {
                console.error('Failed to load GLB:', err);
            });

            function loadPlaneTemplate() {
                gltfLoader.load('/assets/plane.glb', (gltf) => {
                    planeTemplate = gltf.scene;
                    // Normalize template scale to a manageable size
                    const bbox = new THREE.Box3().setFromObject(planeTemplate);
                    const sz = bbox.getSize(new THREE.Vector3());
                    const maxDim = Math.max(sz.x, sz.y, sz.z) || 1;
                    const targetSize = 10; // meters
                    const s = targetSize / maxDim;
                    planeTemplate.scale.setScalar(s);
                    placeExhibitsIfReady();
                }, undefined, (err) => {
                    console.error('Failed to load plane.glb:', err);
                });
            }

            function placeExhibitsIfReady() {
                if (!terrain || !planeTemplate) return;
                const getMapObjects = window.getMapObjects;
                if (!getMapObjects) return;
                const objects = getMapObjects();
                if (!objects || !objects.length) return;

                // Compute 2D data extents
                let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                for (const o of objects) {
                    if (typeof o.x !== 'number' || typeof o.y !== 'number') continue;
                    if (o.x < minX) minX = o.x; if (o.x > maxX) maxX = o.x;
                    if (o.y < minY) minY = o.y; if (o.y > maxY) maxY = o.y;
                }
                if (!isFinite(minX) || !isFinite(maxX) || minX === maxX || minY === maxY) {
                    console.warn('Invalid object coordinate extents; skipping 3D placement');
                    return;
                }

                const tBox = new THREE.Box3().setFromObject(terrain);
                const tMin = tBox.min, tMax = tBox.max;

                const mapRange = (v, a1, a2, b1, b2) => b1 + (b2 - b1) * ((v - a1) / (a2 - a1));

                // Helper to drop a point to terrain surface using raycast
                const dropToTerrain = (x, z) => {
                    const origin = new THREE.Vector3(x, tMax.y + 1000, z);
                    const direction = new THREE.Vector3(0, -1, 0);
                    raycaster.set(origin, direction);
                    const hits = raycaster.intersectObject(terrain, true);
                    if (hits.length) return hits[0].point.y;
                    return tBox.min.y;
                };

                // Clear previous
                for (const g of exhibitGroups) scene.remove(g);
                exhibitGroups.length = 0;

                // Place
                for (const o of objects) {
                    if (!o || typeof o.x !== 'number' || typeof o.y !== 'number') continue;
                    const worldX = mapRange(o.x, minX, maxX, tMin.x, tMax.x);
                    const worldZ = mapRange(o.y, minY, maxY, tMin.z, tMax.z);
                    const worldY = dropToTerrain(worldX, worldZ);

                    const inst = planeTemplate.clone(true);
                    const group = new THREE.Group();
                    group.add(inst);
                    group.position.set(worldX, worldY + 0.5, worldZ);
                    group.userData.mapObject = o;
                    // Orient upright
                    group.rotation.y = Math.random() * Math.PI * 2;

                    // Keep original materials; no base emissive tint
                    scene.add(group);
                    exhibitGroups.push(group);
                }

                // Enable picking
                renderer.domElement.addEventListener('pointerdown', (ev) => {
                    const rect = renderer.domElement.getBoundingClientRect();
                    mouse.x = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
                    mouse.y = -((ev.clientY - rect.top) / rect.height) * 2 + 1;
                    raycaster.setFromCamera(mouse, camera);
                    const meshes = [];
                    for (const g of exhibitGroups) g.traverse((n) => { if ((n).isMesh) meshes.push(n); });
                    const hits = raycaster.intersectObjects(meshes, true);
                    if (hits.length) {
                        let node = hits[0].object;
                        while (node && !node.userData.mapObject) node = node.parent;
                        if (node && node.userData.mapObject && window.selectObject) {
                            window.selectObject(node.userData.mapObject);
                        }
                    }
                });

                // Hover highlight (stronger emissive + slight scale)
                renderer.domElement.addEventListener('pointermove', (ev) => {
                    const rect = renderer.domElement.getBoundingClientRect();
                    mouse.x = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
                    mouse.y = -((ev.clientY - rect.top) / rect.height) * 2 + 1;
                    raycaster.setFromCamera(mouse, camera);
                    const meshes = [];
                    for (const g of exhibitGroups) g.traverse((n) => { if ((n).isMesh) meshes.push(n); });
                    const hits = raycaster.intersectObjects(meshes, true);
                    let newHover = null;
                    if (hits.length) {
                        let n = hits[0].object;
                        while (n && !n.userData.mapObject) n = n.parent;
                        if (n && n.userData.mapObject) newHover = n;
                    }
                    if (hoveredGroup && hoveredGroup !== newHover) {
                        hoveredGroup.scale.set(1, 1, 1);
                    }
                    hoveredGroup = newHover;
                    if (hoveredGroup) {
                        hoveredGroup.scale.set(1.05, 1.05, 1.05);
                        const sel = [];
                        hoveredGroup.traverse((n)=>{ if ((n).isMesh) sel.push(n); });
                        hoverOutlinePass.selectedObjects = sel;
                        bloomPass.strength = HOVER_BLOOM_STRENGTH;
                    } else {
                        hoverOutlinePass.selectedObjects = [];
                        bloomPass.strength = BASE_BLOOM_STRENGTH;
                    }
                });
            }

            // Try to place exhibits again after the pageâ€™s data loads
            window.addEventListener('load', () => setTimeout(placeExhibitsIfReady, 0));
            // Also poll briefly in case mapObjects arrive slightly later
            let tries = 0;
            const timer = setInterval(() => {
                placeExhibitsIfReady();
                if (++tries > 20) clearInterval(timer);
            }, 250);

            function onResize() {
                renderer.setSize(container.clientWidth, container.clientHeight);
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                if (composer) composer.setSize(container.clientWidth, container.clientHeight);
                hoverOutlinePass.setSize(container.clientWidth, container.clientHeight);
            }
            window.addEventListener('resize', onResize);

            (function animate() {
                requestAnimationFrame(animate);
                controls.update();
                composer.render();
            })();
        }
    </script>
</body>
</html>
