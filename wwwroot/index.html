<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Map Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            overflow: hidden;
            height: 100vh;
        }

        .game-container {
            display: flex;
            height: 100vh;
        }

        .map-container {
            flex: 1;
            position: relative;
            background: linear-gradient(45deg, #0f1419 0%, #1a2332 50%, #0f1419 100%);
            overflow: hidden;
        }

        .map-canvas {
            width: 100%;
            height: 100%;
            position: relative;
            cursor: grab;
            z-index: 1; /* above webgl */
        }

        .map-canvas:active {
            cursor: grabbing;
        }

        .map-object {
            position: absolute;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 3px solid #00ff88;
            background: radial-gradient(circle, rgba(0,255,136,0.3) 0%, rgba(0,255,136,0.1) 70%, transparent 100%);
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            box-shadow: 0 0 20px rgba(0,255,136,0.5);
            z-index: 2; /* above map canvas */
        }

        .map-object:hover {
            transform: scale(1.2);
            box-shadow: 0 0 30px rgba(0,255,136,0.8);
        }

        .map-object.discovered {
            border-color: #ff6b35;
            background: radial-gradient(circle, rgba(255,107,53,0.3) 0%, rgba(255,107,53,0.1) 70%, transparent 100%);
            box-shadow: 0 0 20px rgba(255,107,53,0.5);
        }

        .map-object.unlocked {
            border-color: #ffd700;
            background: radial-gradient(circle, rgba(255,215,0,0.3) 0%, rgba(255,215,0,0.1) 70%, transparent 100%);
            box-shadow: 0 0 20px rgba(255,215,0,0.5);
        }

        .sidebar {
            width: 350px;
            background: rgba(0,0,0,0.8);
            backdrop-filter: blur(10px);
            border-left: 1px solid rgba(255,255,255,0.1);
            padding: 20px;
            overflow-y: auto;
        }


        .toolbar {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }


        .object-details {
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            display: none;
        }

        .object-details.active {
            display: block;
        }

        .object-name {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 10px;
            color: #00ff88;
        }

        .object-description {
            margin-bottom: 15px;
            line-height: 1.5;
        }


        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: #00ff88;
            color: #000;
        }

        .btn-secondary {
            background: #ff6b35;
            color: white;
        }

        .btn-info {
            background: #4fc3f7;
            color: white;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        .llm-content {
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            display: none;
        }

        .llm-content.active {
            display: block;
        }

        .content-type-tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
        }

        .tab {
            padding: 5px 10px;
            background: rgba(255,255,255,0.1);
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
        }

        .tab.active {
            background: #00ff88;
            color: #000;
        }

        .video-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .video-container.active {
            display: flex;
        }

        .video-player {
            width: 80%;
            height: 80%;
            border-radius: 10px;
        }

        .close-video {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            font-size: 24px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }

        .loading.active {
            display: block;
        }

        .spinner {
            border: 3px solid rgba(255,255,255,0.3);
            border-top: 3px solid #00ff88;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0,255,136,0.9);
            color: #000;
            padding: 15px 20px;
            border-radius: 10px;
            transform: translateX(400px);
            transition: transform 0.3s ease;
            z-index: 1001;
        }

        .notification.show {
            transform: translateX(0);
        }

        /* Chatbot Popup Modal */
        .chatbot-popup {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: transparent;
            z-index: 2000;
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .chatbot-popup.active {
            visibility: visible;
            opacity: 1;
        }

        .chatbot-modal {
            width: 54%;
            max-width: 360px;
            height: 48%;
            max-height: 420px;
            background: rgba(192, 192, 192, 0.85);
            backdrop-filter: blur(10px) saturate(180%);
            border-radius: 15px;
            display: flex;
            flex-direction: column;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3), 0 0 0 1px rgba(255,255,255,0.3) inset;
            border: 1px solid rgba(255,255,255,0.4);
            position: absolute;
            pointer-events: all;
            opacity: 0;
            transform: scale(0.9) translateY(-10px);
            transition: opacity 0.3s ease, transform 0.3s ease;
        }

        .chatbot-popup.active .chatbot-modal {
            opacity: 1;
            transform: scale(1) translateY(0);
        }

        .chatbot-modal.centered {
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%) scale(0.9);
        }

        .chatbot-popup.active .chatbot-modal.centered {
            transform: translate(-50%, -50%) scale(1);
        }

        .chatbot-arrow {
            position: absolute;
            width: 0;
            height: 0;
            border-style: solid;
            z-index: 2001;
            pointer-events: none;
            opacity: 0;
            display: none;
            transition: opacity 0.3s ease;
        }

        .chatbot-arrow.visible {
            opacity: 1;
            display: block;
        }

        .chatbot-arrow.bottom {
            border-left: 12px solid transparent;
            border-right: 12px solid transparent;
            border-top: 12px solid rgba(192, 192, 192, 0.85);
            filter: drop-shadow(0 -2px 4px rgba(0,0,0,0.2));
        }

        .chatbot-arrow.top {
            border-left: 12px solid transparent;
            border-right: 12px solid transparent;
            border-bottom: 12px solid rgba(192, 192, 192, 0.85);
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.2));
        }

        .chatbot-arrow.left {
            border-top: 12px solid transparent;
            border-bottom: 12px solid transparent;
            border-right: 12px solid rgba(192, 192, 192, 0.85);
            filter: drop-shadow(-2px 0 4px rgba(0,0,0,0.2));
        }

        .chatbot-arrow.right {
            border-top: 12px solid transparent;
            border-bottom: 12px solid transparent;
            border-left: 12px solid rgba(192, 192, 192, 0.85);
            filter: drop-shadow(2px 0 4px rgba(0,0,0,0.2));
        }

        .chatbot-header {
            padding: 20px;
            border-bottom: 1px solid rgba(0,0,0,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .chatbot-header h3 {
            margin: 0;
            color: #1a1a1a;
            font-size: 1.3em;
        }

        .chatbot-close {
            background: rgba(0,0,0,0.1);
            border: none;
            color: #1a1a1a;
            font-size: 24px;
            width: 35px;
            height: 35px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .chatbot-close:hover {
            background: rgba(0,0,0,0.2);
            transform: rotate(90deg);
        }

        .chatbot-messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .chatbot-messages::-webkit-scrollbar {
            width: 8px;
        }

        .chatbot-messages::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.2);
            border-radius: 4px;
        }

        .chatbot-messages::-webkit-scrollbar-thumb {
            background: rgba(0,255,136,0.5);
            border-radius: 4px;
        }

        .chatbot-messages::-webkit-scrollbar-thumb:hover {
            background: rgba(0,255,136,0.7);
        }

        .message {
            padding: 12px 16px;
            border-radius: 12px;
            max-width: 80%;
            word-wrap: break-word;
            line-height: 1.5;
        }

        .message.user {
            background: rgba(0,255,136,0.3);
            border: 1px solid rgba(0,255,136,0.5);
            align-self: flex-end;
            color: #1a1a1a;
        }

        .message.assistant {
            background: rgba(255,255,255,0.6);
            border: 1px solid rgba(255,255,255,0.8);
            align-self: flex-start;
            color: #1a1a1a;
        }

        .message.loading {
            background: rgba(255,255,255,0.6);
            border: 1px solid rgba(255,255,255,0.8);
            align-self: flex-start;
            display: flex;
            align-items: center;
            gap: 10px;
            color: #1a1a1a;
        }

        .message.loading::before {
            content: '';
            width: 16px;
            height: 16px;
            border: 2px solid rgba(0,0,0,0.2);
            border-top: 2px solid #00ff88;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        .chatbot-input-container {
            padding: 20px;
            border-top: 1px solid rgba(0,0,0,0.1);
            display: flex;
            gap: 10px;
        }

        .chatbot-input {
            flex: 1;
            background: rgba(255,255,255,0.7);
            border: 1px solid rgba(0,0,0,0.2);
            border-radius: 8px;
            padding: 12px;
            color: #1a1a1a;
            font-family: inherit;
            font-size: 14px;
            resize: none;
            min-height: 50px;
            max-height: 120px;
            transition: border-color 0.3s ease;
        }

        .chatbot-input:focus {
            outline: none;
            border-color: #00ff88;
            box-shadow: 0 0 5px rgba(0,255,136,0.3);
        }

        .chatbot-input::placeholder {
            color: rgba(0,0,0,0.5);
        }

        .chatbot-send {
            background: #00ff88;
            color: #000;
            border: none;
            border-radius: 8px;
            padding: 12px 24px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .chatbot-send:hover {
            background: #00cc6a;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,255,136,0.3);
        }

        .chatbot-send:disabled {
            background: rgba(0,255,136,0.5);
            cursor: not-allowed;
            transform: none;
        }

        /* WebGL canvas behind UI */
        .webgl-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }
    </style>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.159.0/build/three.module.js",
            "three/examples/jsm/": "https://unpkg.com/three@0.159.0/examples/jsm/"
        }
    }
    </script>
</head>
<body>
    <div class="game-container">
        <div class="map-container">
            <div class="map-canvas" id="mapCanvas">
                <!-- Map objects will be dynamically added here -->
            </div>
        </div>

        <div class="sidebar">
            <div class="toolbar">
                <button class="btn btn-primary" id="toggleMarkersBtn" onclick="toggleMarkers()">Hide Markers</button>
            </div>
            <div class="object-details" id="objectDetails">
                <div class="object-name" id="objectName"></div>
                <div class="object-description" id="objectDescription"></div>

                <div class="llm-content" id="llmContent">
                    <div class="content-type-tabs">
                        <div class="tab active" onclick="showContentType('description')">Description</div>
                    </div>
                    <div id="contentDisplay"></div>
                </div>
            </div>

            <div class="loading" id="loading">
                <div class="spinner"></div>
                <div>Generating content...</div>
            </div>

            <div class="toolbar">
                <button class="btn btn-primary" id="openChatbotBtn" onclick="openChatbot()">ðŸ’¬ Chat with Map Guide</button>
            </div>
        </div>
    </div>

    <div class="video-container" id="videoContainer">
        <button class="close-video" onclick="closeVideo()">&times;</button>
        <video class="video-player" id="videoPlayer" controls>
            Your browser does not support the video tag.
        </video>
    </div>

    <!-- Chatbot Popup Modal -->
    <div class="chatbot-popup" id="chatbotPopup">
        <div class="chatbot-arrow" id="chatbotArrow"></div>
        <div class="chatbot-modal">
            <div class="chatbot-header">
                <h3>ðŸ’¬ Map Guide Chat</h3>
                <button class="chatbot-close" onclick="closeChatbot()">&times;</button>
            </div>
            <div class="chatbot-messages" id="chatbotMessages"></div>
            <div class="chatbot-input-container">
                <textarea 
                    class="chatbot-input" 
                    id="chatbotInput" 
                    placeholder="Ask your map guide anything..."
                    onkeydown="handleChatbotKeydown(event)"></textarea>
                <button class="chatbot-send" id="chatbotSendBtn" onclick="sendChatbotMessage()">Send</button>
            </div>
        </div>
    </div>

    <div class="notification" id="notification"></div>

    <script>
        let mapObjects = [];
        let selectedObject = null;
        let playerId = generatePlayerId();
        let conversationHistory = [];

        // Initialize the game
        async function initGame() {
            await loadMapObjects();
            renderMap();
        }

        // Generate unique player ID (persists across page refreshes)
        function generatePlayerId() {
            // Check if we already have a player ID stored
            let storedId = localStorage.getItem('playerId');
            if (storedId) {
                return storedId;
            }
            
            // Generate a new ID and store it
            const newId = 'player_' + Math.random().toString(36).substr(2, 9) + '_' + Date.now();
            localStorage.setItem('playerId', newId);
            return newId;
        }

        // Load map objects from API
        async function loadMapObjects() {
            try {
                const response = await fetch('/api/Map/objects');
                mapObjects = await response.json();
            } catch (error) {
                console.error('Error loading map objects:', error);
                showNotification('Error loading map objects', 'error');
            }
        }


        // Render the map
        function renderMap() {
            const canvas = document.getElementById('mapCanvas');
            canvas.innerHTML = '';

            mapObjects.forEach(obj => {
                const element = document.createElement('div');
                element.className = 'map-object';
                element.style.left = obj.x + 'px';
                element.style.top = obj.y + 'px';
                element.innerHTML = getObjectIcon(obj.type);
                element.title = obj.name;
                
                if (obj.isUnlocked) {
                    element.classList.add('unlocked');
                } else if (obj.isDiscoverable) {
                    element.classList.add('discovered');
                }

                element.onclick = () => selectObject(obj);
                canvas.appendChild(element);
            });
        }

        // Toggle 2D markers visibility and allow interacting with 3D map
        function toggleMarkers() {
            const canvas = document.getElementById('mapCanvas');
            const btn = document.getElementById('toggleMarkersBtn');
            const hidden = canvas.style.display === 'none';
            if (hidden) {
                canvas.style.display = '';
                btn.textContent = 'Hide Markers';
                // restore pointer events to markers layer
                canvas.style.pointerEvents = '';
            } else {
                canvas.style.display = 'none';
                btn.textContent = 'Show Markers';
            }
        }

        // Get icon for object type
        function getObjectIcon(type) {
            const icons = {
                'Aircraft': 'âœˆï¸',
                'Spacecraft': 'ðŸš€',
                'Satellite': 'ðŸ›°ï¸',
                'Helicopter': 'ðŸš',
                'Rocket': 'ðŸš€',
                'Museum': 'ðŸ›ï¸',
                'default': 'â­'
            };
            return icons[type] || icons.default;
        }

        // Select an object
        function selectObject(obj) {
            // Clear previous description content when selecting new object
            const llmContent = document.getElementById('llmContent');
            llmContent.classList.remove('active');
            const contentDisplay = document.getElementById('contentDisplay');
            contentDisplay.textContent = '';
            
            selectedObject = obj;
            showObjectDetails(obj);
            logInteraction(obj.id, 'click');
            
            // Automatically generate description when object is selected
            generateContent('description');
        }

        // Expose data/functions for module script (3D placement)
        window.getMapObjects = () => mapObjects;
        window.selectObject = selectObject;

        // Show object details
        function showObjectDetails(obj) {
            const details = document.getElementById('objectDetails');
            const name = document.getElementById('objectName');
            const description = document.getElementById('objectDescription');

            name.textContent = obj.name;
            description.textContent = obj.description || 'No description available.';
            
            // Clear the LLM content display when showing new object details
            const llmContent = document.getElementById('llmContent');
            llmContent.classList.remove('active');
            const contentDisplay = document.getElementById('contentDisplay');
            contentDisplay.textContent = '';
            
            details.classList.add('active');
        }

        // Generate content using LLM
        async function generateContent(contentType) {
            if (!selectedObject) return;

            showLoading(true);
            
            try {
                const response = await fetch('/api/LLM/generate-content', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        playerId: playerId,
                        mapObjectId: selectedObject.id,
                        contentType: contentType
                    })
                });

                if (!response.ok) {
                    // Try to extract error message from response
                    let errorMessage = 'Failed to generate content';
                    try {
                        // Clone the response so we can read it multiple times if needed
                        const responseText = await response.text();
                        if (responseText) {
                            try {
                                const errorData = JSON.parse(responseText);
                                if (errorData && typeof errorData === 'object') {
                                    // Handle different error response formats
                                    if (errorData.error) {
                                        // errorData.error can be a string or an object with a message property
                                        if (typeof errorData.error === 'string') {
                                            errorMessage = errorData.error;
                                        } else if (errorData.error.message) {
                                            errorMessage = errorData.error.message;
                                        } else {
                                            errorMessage = String(errorData.error);
                                        }
                                    } else if (errorData.message) {
                                        errorMessage = errorData.message;
                                    }
                                } else if (typeof errorData === 'string') {
                                    errorMessage = errorData;
                                }
                            } catch (jsonError) {
                                // If JSON parsing fails, use the raw text
                                errorMessage = responseText || errorMessage;
                            }
                        }
                    } catch (readError) {
                        console.error('Error reading error response:', readError);
                        errorMessage = `HTTP ${response.status}: ${response.statusText}`;
                    }
                    console.error('API Error:', {
                        status: response.status,
                        statusText: response.statusText,
                        message: errorMessage
                    });
                    throw new Error(errorMessage);
                }

                const data = await response.json();
                displayGeneratedContent(data.content, contentType);
                
                showNotification('Content generated successfully!', 'success');
            } catch (error) {
                console.error('Error generating content:', error);
                const errorMsg = error.message || 'Error generating content';
                showNotification(errorMsg, 'error');
            } finally {
                showLoading(false);
            }
        }

        // Display generated content
        function displayGeneratedContent(content, contentType) {
            const contentDisplay = document.getElementById('contentDisplay');
            contentDisplay.textContent = content;
            
            const llmContent = document.getElementById('llmContent');
            llmContent.classList.add('active');
            
            // Since there's only one tab now, just ensure it's active
            showContentType('description');
        }

        // Show content type tab
        function showContentType(type) {
            const tabs = document.querySelectorAll('.tab');
            tabs.forEach(tab => tab.classList.remove('active'));
            
            // Find the tab that matches the content type
            const targetTab = Array.from(tabs).find(tab => 
                tab.textContent.toLowerCase() === type.toLowerCase()
            );
            
            if (targetTab) {
                targetTab.classList.add('active');
            }
        }

        // Show/hide loading
        function showLoading(show) {
            const loading = document.getElementById('loading');
            if (show) {
                loading.classList.add('active');
            } else {
                loading.classList.remove('active');
            }
        }

        // Show notification
        function showNotification(message, type = 'info') {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.className = `notification show ${type}`;
            
            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000);
        }

        // Log interaction
        async function logInteraction(objectId, interactionType, data = null) {
            try {
                await fetch(`/api/Map/objects/${objectId}/interact`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        playerId: playerId,
                        interactionType: interactionType,
                        interactionData: data
                    })
                });
            } catch (error) {
                console.error('Error logging interaction:', error);
            }
        }


        // Close video
        function closeVideo() {
            const videoContainer = document.getElementById('videoContainer');
            const videoPlayer = document.getElementById('videoPlayer');
            
            videoContainer.classList.remove('active');
            videoPlayer.pause();
            videoPlayer.currentTime = 0;
        }

        // Chatbot Popup Functions
        function openChatbot() {
            if (!selectedObject) {
                showNotification('Please select a map object first', 'error');
                return;
            }
            
            const popup = document.getElementById('chatbotPopup');
            const modal = popup.querySelector('.chatbot-modal');
            
            // Hide arrow - not used for markers or 3D objects
            const arrow = document.getElementById('chatbotArrow');
            arrow.style.display = 'none';
            
            // Show popup first so we can measure it
            popup.classList.add('active');
            
            // Use double requestAnimationFrame to ensure modal is fully rendered
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    let objCenterX, objCenterY;
                    let foundPosition = false;
                    
                    // First, try to find 2D DOM marker
                    const mapCanvas = document.getElementById('mapCanvas');
                    const objectElements = mapCanvas.querySelectorAll('.map-object');
                    let objectElement = null;
                    
                    for (let elem of objectElements) {
                        const objX = parseFloat(elem.style.left);
                        const objY = parseFloat(elem.style.top);
                        if (Math.abs(objX - selectedObject.x) < 1 && Math.abs(objY - selectedObject.y) < 1) {
                            objectElement = elem;
                            break;
                        }
                    }
                    
                    // If object element found, position popup near it
                    if (objectElement) {
                        const objRect = objectElement.getBoundingClientRect();
                        objCenterX = objRect.left + objRect.width / 2;
                        objCenterY = objRect.top + objRect.height / 2;
                        foundPosition = true;
                    }
                    
                    // If position found, position popup near it
                    if (foundPosition) {
                        // Get actual modal dimensions now that it's rendered
                        const modalRect = modal.getBoundingClientRect();
                        const modalWidth = modalRect.width || 360;
                        const modalHeight = modalRect.height || 420;
                        
                        const offset = 20; // Distance from object
                        
                        // Determine best position (prefer bottom-right, but adjust based on viewport)
                        let popupX, popupY;
                        
                        const viewportWidth = window.innerWidth;
                        const viewportHeight = window.innerHeight;
                        
                        // Check if object is on left or right side
                        const isLeftSide = objCenterX < viewportWidth / 2;
                        const isTopSide = objCenterY < viewportHeight / 2;
                        
                        if (isLeftSide) {
                            // Position to the right of object
                            popupX = objCenterX + offset;
                        } else {
                            // Position to the left of object
                            popupX = objCenterX - offset - modalWidth;
                        }
                        
                        if (isTopSide) {
                            // Position below object
                            popupY = objCenterY + offset;
                        } else {
                            // Position above object
                            popupY = objCenterY - offset - modalHeight;
                        }
                        
                        // Ensure popup stays within viewport
                        popupX = Math.max(10, Math.min(popupX, viewportWidth - modalWidth - 10));
                        popupY = Math.max(10, Math.min(popupY, viewportHeight - modalHeight - 10));
                        
                        // Apply positions
                        modal.classList.remove('centered');
                        modal.style.left = popupX + 'px';
                        modal.style.top = popupY + 'px';
                    } else {
                        // Fallback: center the popup if object element not found (3D objects)
                        modal.classList.add('centered');
                        modal.style.left = '50%';
                        modal.style.top = '50%';
                    }
                });
            });
            
            // Load conversation history from localStorage
            loadConversationHistory();
            
            // Focus on input
            setTimeout(() => {
                document.getElementById('chatbotInput').focus();
            }, 100);
        }

        function closeChatbot() {
            const popup = document.getElementById('chatbotPopup');
            const modal = popup.querySelector('.chatbot-modal');
            
            // Trigger fade out
            popup.classList.remove('active');
            
            // Wait for transition to complete before resetting styles
            setTimeout(() => {
                if (!popup.classList.contains('active')) {
                    modal.style.left = '';
                    modal.style.top = '';
                    modal.classList.remove('centered');
                }
            }, 300); // Match the transition duration (0.3s)
        }

        function loadConversationHistory() {
            const historyKey = `chatbot_history_${playerId}_${selectedObject.id}`;
            const stored = localStorage.getItem(historyKey);
            if (stored) {
                try {
                    conversationHistory = JSON.parse(stored);
                } catch (e) {
                    console.error('Error loading conversation history:', e);
                    conversationHistory = [];
                }
            } else {
                conversationHistory = [];
            }
            
            renderConversationHistory();
        }

        function saveConversationHistory() {
            if (!selectedObject) return;
            const historyKey = `chatbot_history_${playerId}_${selectedObject.id}`;
            localStorage.setItem(historyKey, JSON.stringify(conversationHistory));
        }

        function renderConversationHistory() {
            const messagesContainer = document.getElementById('chatbotMessages');
            messagesContainer.innerHTML = '';
            
            if (conversationHistory.length === 0) {
                const welcomeMsg = document.createElement('div');
                welcomeMsg.className = 'message assistant';
                welcomeMsg.textContent = `Hello! I'm your map guide for ${selectedObject.name}. Ask me anything about this object!`;
                messagesContainer.appendChild(welcomeMsg);
            } else {
                conversationHistory.forEach(msg => {
                    const messageDiv = document.createElement('div');
                    messageDiv.className = `message ${msg.role}`;
                    messageDiv.textContent = msg.content;
                    messagesContainer.appendChild(messageDiv);
                });
            }
            
            // Scroll to bottom
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        function addMessageToHistory(role, content) {
            conversationHistory.push({ role, content });
            saveConversationHistory();
            renderConversationHistory();
        }

        function handleChatbotKeydown(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendChatbotMessage();
            }
        }

        async function sendChatbotMessage() {
            const chatInput = document.getElementById('chatbotInput');
            const sendBtn = document.getElementById('chatbotSendBtn');
            const messagesContainer = document.getElementById('chatbotMessages');
            const message = chatInput.value.trim();

            if (!message) {
                return;
            }

            if (!selectedObject) {
                showNotification('Please select a map object first', 'error');
                return;
            }

            // Disable input and button
            chatInput.disabled = true;
            sendBtn.disabled = true;

            // Add user message to history and UI
            addMessageToHistory('user', message);
            chatInput.value = '';

            // Show loading message
            const loadingMsg = document.createElement('div');
            loadingMsg.className = 'message loading';
            loadingMsg.textContent = 'Map guide is thinking...';
            messagesContainer.appendChild(loadingMsg);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;

            try {
                // Prepare conversation history for API (last 10 messages, excluding the current message we just added)
                // We exclude the last message since it's the current one being sent
                const historyForApi = conversationHistory.slice(0, -1).slice(-10).map(msg => ({
                    role: msg.role === 'user' ? 'user' : 'assistant',
                    content: msg.content
                }));

                const response = await fetch('/api/LLM/generate-content', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        playerId: playerId,
                        mapObjectId: selectedObject.id,
                        contentType: 'conversation',
                        specificRequest: message,
                        conversationHistory: historyForApi
                    })
                });

                // Remove loading message
                loadingMsg.remove();

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('API error response:', response.status, errorText);
                    throw new Error(`Failed to get response from map guide: ${response.status}`);
                }

                const data = await response.json();
                console.log('Chatbot response data:', data);
                
                // Handle both camelCase and PascalCase property names
                const content = data.content || data.Content;
                
                if (!content) {
                    console.error('No content in response:', data);
                    throw new Error('Response missing content field');
                }
                
                // Add assistant response to history and UI
                addMessageToHistory('assistant', content);
                
            } catch (error) {
                console.error('Error sending chat message:', error);
                
                // Remove loading message
                loadingMsg.remove();
                
                // Add error message
                const errorMsg = document.createElement('div');
                errorMsg.className = 'message assistant';
                errorMsg.textContent = 'Sorry, I encountered an error. Please try again.';
                messagesContainer.appendChild(errorMsg);
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
                
                showNotification('Error communicating with map guide', 'error');
            } finally {
                // Re-enable input and button
                chatInput.disabled = false;
                sendBtn.disabled = false;
                chatInput.focus();
            }
        }

        // Close chatbot when clicking outside
        document.getElementById('chatbotPopup')?.addEventListener('click', (e) => {
            const modal = e.currentTarget.querySelector('.chatbot-modal');
            if (e.target === e.currentTarget || (!modal.contains(e.target) && e.target.id !== 'chatbotArrow')) {
                closeChatbot();
            }
        });

        // Initialize the game when page loads
        document.addEventListener('DOMContentLoaded', initGame);
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader.js';
        import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
        import { OutlinePass } from 'three/examples/jsm/postprocessing/OutlinePass.js';
        import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';

        const container = document.querySelector('.map-container');
        if (!container) {
            console.warn('Three.js init skipped: .map-container not found');
        } else {
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.75));
            renderer.setSize(container.clientWidth, container.clientHeight);
        container.prepend(renderer.domElement);
        renderer.domElement.classList.add('webgl-canvas');

            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 10000);
            const controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 5;
            controls.maxDistance = 5000;

            scene.add(new THREE.HemisphereLight(0xffffff, 0x202020, 0.8));
            const dir = new THREE.DirectionalLight(0xffffff, 0.6);
            dir.position.set(100, 200, 100);
            scene.add(dir);

            // Postprocessing composer: render -> hoverOutline -> mild bloom (hover only)
            const composer = new EffectComposer(renderer);
            const renderPass = new RenderPass(scene, camera);
            composer.addPass(renderPass);
            // Stronger outline for hovered exhibit
            const hoverOutlinePass = new OutlinePass(new THREE.Vector2(container.clientWidth, container.clientHeight), scene, camera);
            hoverOutlinePass.edgeStrength = 3.0;
            hoverOutlinePass.edgeGlow = 0.0;
            hoverOutlinePass.edgeThickness = 1.6;
            hoverOutlinePass.visibleEdgeColor.set(0x00ff88);
            hoverOutlinePass.hiddenEdgeColor.set(0x004422);
            composer.addPass(hoverOutlinePass);
            const BASE_BLOOM_STRENGTH = 0.0;
            const HOVER_BLOOM_STRENGTH = 0.45;
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(container.clientWidth, container.clientHeight), BASE_BLOOM_STRENGTH, 0.6, 0.85);
            composer.addPass(bloomPass);

            const gltfLoader = new GLTFLoader();
            const dracoLoader = new DRACOLoader();
            dracoLoader.setDecoderPath('https://unpkg.com/three@0.159.0/examples/jsm/libs/draco/');
            gltfLoader.setDRACOLoader(dracoLoader);

            let terrain = null;
            let planeTemplate = null;
            const exhibitGroups = [];
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            let hoveredGroup = null;

            // Load terrain first
            gltfLoader.load('/assets/mansion_map.glb', (gltf) => {
                terrain = gltf.scene;
                scene.add(terrain);

                const box = new THREE.Box3().setFromObject(terrain);
                const size = box.getSize(new THREE.Vector3());
                const center = box.getCenter(new THREE.Vector3());

                controls.target.copy(center);
                const maxDim = Math.max(size.x, size.y, size.z);
                const fitDist = maxDim * 1.2;
                camera.position.set(center.x - fitDist * 0.7, center.y + fitDist * 0.5, center.z + fitDist * 0.7);
                controls.update();

                // After terrain, load plane template
                loadPlaneTemplate();
            }, (evt) => {
                if (evt.lengthComputable) {
                    const pct = (evt.loaded / evt.total * 100).toFixed(1);
                    console.log(`Loading model: ${pct}%`);
                } else {
                    console.log(`Loading model: ${evt.loaded} bytes`);
                }
            }, (err) => {
                console.error('Failed to load GLB:', err);
            });

            function loadPlaneTemplate() {
                gltfLoader.load('/assets/plane.glb', (gltf) => {
                    planeTemplate = gltf.scene;
                    // Normalize template scale to a manageable size
                    const bbox = new THREE.Box3().setFromObject(planeTemplate);
                    const sz = bbox.getSize(new THREE.Vector3());
                    const maxDim = Math.max(sz.x, sz.y, sz.z) || 1;
                    const targetSize = 10; // meters
                    const s = targetSize / maxDim;
                    planeTemplate.scale.setScalar(s);
                    placeExhibitsIfReady();
                }, undefined, (err) => {
                    console.error('Failed to load plane.glb:', err);
                });
            }

            function placeExhibitsIfReady() {
                if (!terrain || !planeTemplate) return;
                const getMapObjects = window.getMapObjects;
                if (!getMapObjects) return;
                const objects = getMapObjects();
                if (!objects || !objects.length) return;

                // Compute 2D data extents
                let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                for (const o of objects) {
                    if (typeof o.x !== 'number' || typeof o.y !== 'number') continue;
                    if (o.x < minX) minX = o.x; if (o.x > maxX) maxX = o.x;
                    if (o.y < minY) minY = o.y; if (o.y > maxY) maxY = o.y;
                }
                if (!isFinite(minX) || !isFinite(maxX) || minX === maxX || minY === maxY) {
                    console.warn('Invalid object coordinate extents; skipping 3D placement');
                    return;
                }

                const tBox = new THREE.Box3().setFromObject(terrain);
                const tMin = tBox.min, tMax = tBox.max;

                const mapRange = (v, a1, a2, b1, b2) => b1 + (b2 - b1) * ((v - a1) / (a2 - a1));

                // Helper to drop a point to terrain surface using raycast
                const dropToTerrain = (x, z) => {
                    const origin = new THREE.Vector3(x, tMax.y + 1000, z);
                    const direction = new THREE.Vector3(0, -1, 0);
                    raycaster.set(origin, direction);
                    const hits = raycaster.intersectObject(terrain, true);
                    if (hits.length) return hits[0].point.y;
                    return tBox.min.y;
                };

                // Clear previous
                for (const g of exhibitGroups) scene.remove(g);
                exhibitGroups.length = 0;

                // Place
                for (const o of objects) {
                    if (!o || typeof o.x !== 'number' || typeof o.y !== 'number') continue;
                    const worldX = mapRange(o.x, minX, maxX, tMin.x, tMax.x);
                    const worldZ = mapRange(o.y, minY, maxY, tMin.z, tMax.z);
                    const worldY = dropToTerrain(worldX, worldZ);

                    const inst = planeTemplate.clone(true);
                    const group = new THREE.Group();
                    group.add(inst);
                    group.position.set(worldX, worldY + 0.5, worldZ);
                    group.userData.mapObject = o;
                    // Orient upright
                    group.rotation.y = Math.random() * Math.PI * 2;

                    // Keep original materials; no base emissive tint
                    scene.add(group);
                    exhibitGroups.push(group);
                }

                // Enable picking
                renderer.domElement.addEventListener('pointerdown', (ev) => {
                    const rect = renderer.domElement.getBoundingClientRect();
                    mouse.x = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
                    mouse.y = -((ev.clientY - rect.top) / rect.height) * 2 + 1;
                    raycaster.setFromCamera(mouse, camera);
                    const meshes = [];
                    for (const g of exhibitGroups) g.traverse((n) => { if ((n).isMesh) meshes.push(n); });
                    const hits = raycaster.intersectObjects(meshes, true);
                    if (hits.length) {
                        let node = hits[0].object;
                        while (node && !node.userData.mapObject) node = node.parent;
                        if (node && node.userData.mapObject && window.selectObject) {
                            window.selectObject(node.userData.mapObject);
                        }
                    }
                });

                // Hover highlight (stronger emissive + slight scale)
                renderer.domElement.addEventListener('pointermove', (ev) => {
                    const rect = renderer.domElement.getBoundingClientRect();
                    mouse.x = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
                    mouse.y = -((ev.clientY - rect.top) / rect.height) * 2 + 1;
                    raycaster.setFromCamera(mouse, camera);
                    const meshes = [];
                    for (const g of exhibitGroups) g.traverse((n) => { if ((n).isMesh) meshes.push(n); });
                    const hits = raycaster.intersectObjects(meshes, true);
                    let newHover = null;
                    if (hits.length) {
                        let n = hits[0].object;
                        while (n && !n.userData.mapObject) n = n.parent;
                        if (n && n.userData.mapObject) newHover = n;
                    }
                    if (hoveredGroup && hoveredGroup !== newHover) {
                        hoveredGroup.scale.set(1, 1, 1);
                    }
                    hoveredGroup = newHover;
                    if (hoveredGroup) {
                        hoveredGroup.scale.set(1.05, 1.05, 1.05);
                        const sel = [];
                        hoveredGroup.traverse((n)=>{ if ((n).isMesh) sel.push(n); });
                        hoverOutlinePass.selectedObjects = sel;
                        bloomPass.strength = HOVER_BLOOM_STRENGTH;
                    } else {
                        hoverOutlinePass.selectedObjects = [];
                        bloomPass.strength = BASE_BLOOM_STRENGTH;
                    }
                });
            }

            // Try to place exhibits again after the pageâ€™s data loads
            window.addEventListener('load', () => setTimeout(placeExhibitsIfReady, 0));
            // Also poll briefly in case mapObjects arrive slightly later
            let tries = 0;
            const timer = setInterval(() => {
                placeExhibitsIfReady();
                if (++tries > 20) clearInterval(timer);
            }, 250);

            function onResize() {
                renderer.setSize(container.clientWidth, container.clientHeight);
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                if (composer) composer.setSize(container.clientWidth, container.clientHeight);
                hoverOutlinePass.setSize(container.clientWidth, container.clientHeight);
            }
            window.addEventListener('resize', onResize);

            (function animate() {
                requestAnimationFrame(animate);
                controls.update();
                composer.render();
            })();
        }
    </script>
</body>
</html>

